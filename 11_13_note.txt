------bread(read block)
缓冲区 在文件复用条件下(多次读取重复的文件时,由于之前文件已经从硬盘读到内存中)缓冲区速度会很快.硬盘读内存时间小于 < 内存读内存小2个数量级(前提)
块操作避免(磁盘的)碎片整理个
一旦数据进入缓冲区,则让该数据在缓冲区里等待的时间足够长(更有可能下次再次访问)

设备号 + 块号(hd) -> 唯一确定块
b_count 缓冲块有多少用户共享
b_wait 哪个进程等待缓冲块

我们原则是:1、尽可能让数据尽可能呆在缓冲区里,所以当数据块的count为0时,仍旧不把缓冲区清空.只有当缓冲区满时,才让count为0的数据爪巴(我们让count刚刚为0的数据再次入缓冲区)2、如果文件在缓冲区里,直接读

ssd 从stream变成直接寻址后,会快很多
机械硬盘 能废掉缓冲区? 尽可能顺着磁道方向存储,提升机械硬盘速度

----
get_blk
if(!(bh = get_blk))先在缓冲区里找是否有数据

----
get_blk(dev, block)从设备和块来确定blk
先找count为0的数据(开机到现在没人用或者刚用完count=0)
沿着 free_list遍历(蓝叉子)
什么时候加锁?给谁加锁? 加锁是避免竞争(生产者消费者->至少有一个读)
硬盘写缓冲区(自动化过程,生产者),进程读缓冲(消费者).因此要锁
缓冲块被进程写过 -> b_dirt,badness 哪一个更差,dirt更差
---
get_hash_table()
在hash_table里找到buffer_head(find_buffer)
在此之前我们没动过缓冲区,因此在这之前缓冲区为空(没有写入数据,不代表真为空)
----
find_buffer
hash算法 : _hashfn (dev ^ block) % 307 hash_table长307
list的速度比hash表查找速度要慢2个数量级,因此list的长度也要尽可能小;hash长度尽可能多
第一次我们返回NULL(因为没有)
