IDT GPT表
GDT表不能随意更改(其中包含特权字段),因此在应用程序中写相应的代码(gdt)无法使用

idt中断描述符表 gdt全局描述符表
lidt idt_48(address, base, limit),将定义的idt表的地址装进idtr(中断描述符表)寄存器,由cpu进行读取. 初始状态下 idt表的基址和限长为0
其中idtr寄存器中存储的地址,才认为时真的idt表(同样gdt如此)

下课看一下gdt描述的字段.

jmpi 0, 8(0:ip,8:bias)

--------
head.s(主要进行分页设置)
存在于线性地址的开头,从 jmpi 0, 8跳转过来后, 存在的是head.s的代码,执行的过程中原地建立分页(做页目录表与页表)

startup_32 线性地址为0，整个段的起始位置
已经是保护模式(在之前setup.s中A20打开进入保护模式)
目前只有保护模式没有分页,(查ia32)因此:线性 address-->物理address 是一一对应
(若进行分页,则地址并非一一对应)

给内核与用户分别别进行分页(分页与cpu有关，intel两级页表(一级页目录表,二级页表),
页目录表管理页表项(1k项)，每一项指向一个页表;每一个页表有1k项,每一项指向一个页,每一页有4k项)

4kk = 4M,一个页表管理4M物理地址,一个页表项管理1k个页表,一个页表有4k个地址

e.g address:[10][10][12]
            /
           /
页目录表,也占一页(4k)


内核:恒等映射,线性地址 === 物理地址,编码一致,方便内核进行操作
内核占用4个页表,在该版本中用户与内核的页表混用

ceil to ax(set ds to 0x10 = 10000, 0特权gdt的第三项(内核数据>      段),返回到setup.s的gdt表创建的第三项(2 = b'10), 与jmpi 0, 8一致)

在汇编中加下划线中,c语言写的代码的标识符(_stack_start)

setup_idt 建立idt表
保护模式：段选择符(jmpi 0, 8中的8)  中断服务程序偏移地址(31.16，15.0)
实模式：        cs                            ip

0x10 内核数据段 0x8内核代码段,后续中断程序在内核代码段上
0x0008 0000

setup_gdt  再次load gdt_descr

pg_dir pg0 pg1 pg2 pg3 pg4 一共五页

pushl $_main main函数代表kernel(内核主程序),因此避免返回到head.s来(到底谁是底层?)
函数调用与返回::call == push ip(当前的ip指向下一条指令) 压栈; ret == pop ip
在这里假装有人调用过main,在这里手写进栈.所以当head.s执行完在执行main
在 :218 ret 使用返回调用main函数

一个页表项4个字节, 32位;实际上20位就够(4k对齐,cpu硬件要求)cpu每4k往下寻找
对齐十分严格,因此不用保留最后12位偏移(32 - 12)

其中低12位中的低3位su(超级用户),rw(读写),p(存在), 因为7 = 111,最低位:对应页表是否分页,p=0未分页(因此执行缺页中断);是在cpu上进行访问控制
还剩9位,例如脏页位等等.

把页表刷到页目录表项里了
在这里使用cr3 控制寄存器,控制分页. 把0赋给cr3,指向页目录表的地址(0x0)


用户:完全无法直接找到映射关系(

