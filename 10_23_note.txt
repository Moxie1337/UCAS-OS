func copy_process
建立task指针 task_struct *p(进程重点)
get_free_page() mem_map的引用计数为0 -> 得到空闲页；从高往低找空闲页(why),找到的页给谁用了?分配的是线性还是物理页?这个页是几特权的? 地址是16M的那个页(物理内存),

union task_union
{
	struct task_struct task;
	char struct[PAGE_SIZE];
}

p = (struct task_struct *) get_free_page() 强制类型转化, 这里为子进程分配task指针,内核栈与task_struct的共用体 -> task_union,从这之后已经有进程编号了(进程标志)
task[nr] = p, 进程挂号
*p = *current(当前是父进程的task_struct,进程0) 只是把进程0的task_struct赋值给进程0的,但是进程0的栈不能给进程1的栈。
在task_struct中甚至ldt和tss也复制过去了,因此父进程和子进程的数据段与代码段共享(为什么不使用template) 子进程利用父进程复制过程作为引导(多个进程都使用相同的资源时,父进程因此可以不断复制给子进程)
注意,栈的内容没有复制过来

之后更改子进程p的状态(进程状态设置为 挂起状态,万一跑起来了呢??)
windows 时钟 抢占式,服务器 非抢占式(当时钟中断来时,是否能跑? 注意是否处于内核态)

tss.eax = 0
tss.eip = eip(int 0x80的下一行代码)

if(copy_mem(nr, p)) 
新旧代码、数据的 基址 限长
得到父进程的限长 get_limit() 0x0f 用户ldt的代码段  0x17 用户ldt的数据段
由此找到了父进程的基址和偏移

新代码段基址与新数据段基址对齐 64M (每个进程64M大小) 4G内存大小均分给64个进程,每个进程有64M。随后把子进程的数据段与代码段的基址的值存放到ldt中(存放到ldt中才说明建立好了)

物理地址需要动页表，以上都是动线性地址。那么进程0有没有动页表?
+111 页表项, 第一位p位,页表不分配就是0
0进程的 代码段基址0， 限长为A0 * 4k = 640k [0 - 640k], 与内核放在一块
内核的(代码段数据段)基址也是0，限长为 xxx

惊天结论!内核段的代码与内核代码相同(他们的段是重叠的),一会儿当内核，一会儿当用户程序(进程0)用.  0特权 -> mts 段翻为3特权
进程1挪到[64M-128M]上去了

copy_page_table 开始做物理地址,动页表(from(父进程的段基址) to(子进程的段基址) size(限长))
在这里页表都随之复制.
22个1, 页目录表 页表 页表项 10 10 12
一个页表的覆盖范围,也就是一个页目录表项覆盖的范围

cpu提出的要求,分页要求对齐 页目录表项要求4M对齐
from_dir 父进程的页目录表项的位置,(一共一个页目录表 <-> 一个线性地址空间(4G))
将父进程的物理地址(要从页目录表项开始寻找)然后与子进程的页目录表项开始复制

*to_dir 表示表项本身 页目录表项的后12位无效(用来存标志位) p位1
父进程有的我就复制,没有的话就跳过
