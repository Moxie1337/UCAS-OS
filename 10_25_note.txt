----copy_page_table

get_free_page 从末尾开始遍历空页表

              /
内存 mem [16MB] [.....[task_struct][char]]
			      	\					|
												|
						------------
						|
	  task[0][1]

最外面大循环 遍历页目录表项(from_dir, to_dir),并且复制页表项

copy_page_tables
页表4k对齐,一个页表管理4M地址,一个有1k页表项,一个页表项有4k个地址
页目录表项 页表 页表项
[10]			 [10]  [12]

1 & (*to_dir) 页目录表项的指针的值(页表项) 和 最低位1 与,之前还未进行分页,但如果结果位1,则panic(还没给进程0分类物理内存,不该有p位)
1 & (*from_dir) 一个进程最大64M，一个页表项管理4M,因此父进程最多16个页表项

get_free_page(),创建子进程(进程1)的页表,并且复制父进程的页表项
head.s 给kernel分配了4个页目录表项(16M),进程0与kernel的基地址一致.当时分配页表的时候末尾+7 111(3特权) 不是3 011(0特权) 特权违规

目前有两个 get_free_page,一个是分配union，另一个是复制页表项(都给进程1服务)
应不应该进程能够访问自己的这两个页(?)不能 1.对于页表来说应该由kernel管理,而非今晨个管理；2.如果修改了自己进程的页表项,可以访问到其他进程的物理地址(危险) (为进程服务,但进程无权主动访问)

子进程共享父进程的物理地址(页表项复制)
cr3 页目录表项 页表项 的偏移和前20位 都是物理地址,其余都是线性地址.
内核写物理地址和线性地址是一致的(恒等映射),实际上计算的都是线性地址,只不过和物理地址相同.但是还没保证进程1找到自己的页
一个线性页 -> 一个物理页
[64M][64M]

进程0的线性地址 映射的 物理地址 与进程1的线性地址空间是一样的,但是进程0

head.s 做了五个页(kernel的页)(+7) 挂在内核的线性地址空间上,并没挂在进程0的线性地址空间

get_free_page 在两个地方调用
copy_process 内核函数 挂在内核的分页上,在head.s上分布 以恒等映射挂上的
copy_page_tables 也是内核函数 ，也在内核的代码段数据段上跑,页挂在内核的分页上.
但实际上长度不够(?) 没有在挂一次进程0的线性地址空间.

*to_dir 页目录表项的 ... | 7
nr = (from == 0)?0xA0(160):1024(1K)

this_page &= ~2 只有第二位置0(自适应机器系统的长度)
111 -> 101 p位有，rw位没有(目前是只读)，su(是user).让复制的原数据只读
copy_on_write共享操作
共享后 mem_map 引用计数+1

invalidate() 页表更新后,刷TLB(刷cr3)

copy_mem 任何父进程创建子进程都走到这个函数,任何子进程跑的实际上是父进程的代码(复制中没有复制栈，内核栈不一致因此数据不一致)
