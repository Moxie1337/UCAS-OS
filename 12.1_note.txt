bootsector 中 root_defined定义了根设备
当时定义的根设备是软盘

之后再sys_setup上调用
rd_load() 和 mount_root()
将虚拟盘指定为根设备
根设备上的文件系统加载到根设备上

在当时划分物理内存的时候，我们把缓冲区的末端作为虚拟盘(2M)
虚拟盘区别：硬盘 do_hd_request;虚拟盘 do_rd_request
读硬盘需要需要等 硬件中断(硬盘太慢)，但是虚拟盘本身就在内存里，内存的速度快，因此不需要发送中断
本质上还是内存，但是他当作一个外设作为处理。

rd_load将虚拟盘作为根设备。这个虚拟盘虚拟谁？答：软盘(1.44M) 把软盘虚拟到内存中(虚拟盘)
我们就把软盘映射到虚拟盘里(按照软盘的格式进行复制)，所以跑的速度快


超级块->逻辑块位图 i节点位图 ->找到唯一的i节点
一个i节点包含多个数据块

创建新文件:
1、找到空闲的i节点(查i节点位图，通过空闲的序号找到对应的i节点)
2、拷贝内容的时候我们要在逻辑块位图中找到空闲的数据块，并挂载到i节点的izone


-------------------
底下都是在硬盘里的，上面是在内存里的

超级块super_block  一个超级快对应一个文件系统，一共最多八个文件系统
超级块数组[8],每当打开文件，就把该文件系统的根i节点对应的超级块送到超级块上
目前我们把虚拟盘的超级块放到超级快数组里

m_inode inode_table[32] 只要打开一个i节点(在内存中使用)，就要在inode_table上拷进去
文件与i节点是一一对应的,i节点一定是某个文件系统的一个文件，

每个i节点对应一个文件；目录i节点对应一个目录文件(目录文件他也是文件) 
因此每一个inode_table里的m_inode 可以装目录文件的inode，也可以装文件的inode
总结:只要在该os中打开的文件,都要上到inode_table (我们在找文件加夹的某个文件时，我们实际上要存储每一个目录节点到inode_table上，但是最终我们只保留最终的目的文件节点)

其中数组中的 信息比硬盘中的信息要多
m_inode 在硬盘中的信息要比在内存中的信息要少


stryct file
{
	struct *m_inode f_inode
}
指向inode的指针

file file_table[64]


-------------
struct task_struct中与文件有关的信息

struct file* filp[20] 这个数组属于每一个进程(每一个进程只能由20个文件，这里也包含重复的文件)

从进程角度说，一个进程open 会返回一个句柄
1、首先在filp中找到空闲项
2、返回的句柄就是filp的下标
3、什么叫打开一个文件? 首先i节点对应一个设备，设备的块号对应一个根i节点，每个根i节点对应一个超级快


------------
实际上我们用两层区分了文件系统
上层更加偏向OS的管理
下层更加偏向用户的使用

struct super_block
struct m_inode * s_isup 根目录的i节点
xxx              i_mount 根i节点挂载在



_____________
rd_load
看赵炯
brada

设备的第一个块时引导块 block + 1， 第二个是超级块block + 2

魔术MAGIC minux操作系统的文件系统

ROOT_DEV 最后把设备号变为虚拟盘 设备定下来，但是文件系统还没上来
--------------
mount_root

首先判断
初始化file_table[64]
之后初始化超级块super_block[8]
当前我们的设备是虚拟盘
p = read_super(ROOT_DEV)
之后我们读取根设备(虚拟盘)读取到超级块的数据里(虽然目前虚拟盘就在内存里，但是我们依旧以外设对其进行管理)把虚拟盘中的超级块 读取到 super_block[0]中
同时还把硬盘超级块中的缺失的信息补上
p代表超级块，代表一个盘，表示根inode

iget(ROOT_DEV,1第一个节点是根inode) 我们找虚拟盘中的（根文件系统的）根inode

核心部分
p->s_isup = p->s_imount = mi 加载根设备的根文件目录

current -> pwd (进程1)的进程工作目录 根文件系统的根文件目录
因此进程0没有文件系统，他只有怠速

****目前是进程1

root是该进程能访问到的最根的节点 current->root = mi


返回到task_struct中的结构，其中也包含了 root和pwd
进程0的模板INIT_TASK： pwd,root,executable都是NULL,说明进程0没有

在copy_process中也有相关的定义

filp当前进程打开最多文件个数，包含重复文件

*p = *current current为父进程，把全部内容给了p。因此子进程全部继承了父进程的()
子进程同样也要复制父进程打开的文件，然后引用计数++

0创建1的时候 由于 0的pwd和root都为NULL，因此刚创建完进程1也没有
等到mount_root(sys_setup中)这行之后我们 进程1的pwd和root才有值，由此进程1才有访问的能力
除非chroot或者chdir,所有子进程的pwd和root都一致

这里的root绝对路径是进程能访问的最根目录，该位置不一定是文件系统的根i节点，也不一定是根文件系统的根i节点
但是目前进程1的root是根文件系统的根i节点。

